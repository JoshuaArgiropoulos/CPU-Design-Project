/*module division(quotient, remain, numer, denom));
input [31:0] numer, denom;
output [31:0] quotient, remain;

always @(*) begin

if(sign) ra <= value1 - value2;
else ra <= value1 + value2;
end
assign result = ra;
endmodule*/

module non_restoring_divider(
  input signed [31:0] dividend,
  input signed [31:0] divisor,
  output signed [31:0] quotient,
  output signed [31:0] remainder
);

  reg signed [31:0] dividend_reg;
  reg signed [31:0] divisor_reg;
  reg signed [31:0] quotient_reg;
  reg signed [31:0] remainder_reg;
  reg signed [31:0] temp_reg;

  // Initialize registers
  initial begin
    dividend_reg = dividend;
    divisor_reg = divisor;
    quotient_reg = 0;
    remainder_reg = 0;
  end

  always @(*) begin
    if (divisor_reg < 0) begin
      divisor_reg = -divisor_reg; // Make divisor positive
      dividend_reg = -dividend_reg; // Make dividend negative
    end

    quotient_reg = 0;
    remainder_reg = dividend_reg;

    // Perform division
    for (int i = 31; i >= 0; i = i - 1) begin
      temp_reg = remainder_reg << 1;
      if (temp_reg >= 0) begin
        remainder_reg = temp_reg - divisor_reg;
        quotient_reg[i] = 1;
      end
      else begin
        remainder_reg = temp_reg;
        quotient_reg[i] = 0;
      end
    end

    // Set quotient and remainder outputs
    quotient = quotient_reg;
    remainder = remainder_reg;

    // Make quotient and remainder negative if necessary
    if ((dividend < 0) != (divisor < 0)) begin
      quotient = -quotient;
      if (remainder != 0) remainder = divisor_reg - remainder;
      remainder = -remainder;
    end
  end
endmodule